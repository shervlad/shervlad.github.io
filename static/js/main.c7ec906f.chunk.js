(this.webpackJsonpwebsite=this.webpackJsonpwebsite||[]).push([[0],{32:function(e,t,a){},43:function(e,t,a){e.exports=a(60)},48:function(e,t,a){},49:function(e,t,a){},60:function(e,t,a){"use strict";a.r(t);var n=a(0),r=a.n(n),l=a(19),o=a.n(l),i=(a(48),a(49),a(7)),s=a(8),c=a(10),m=a(9),h=a(62),u=a(63),d=a(64),p=a(41),g=a(6),f=a(3),w=a(65),b=function(e){Object(c.a)(a,e);var t=Object(m.a)(a);function a(){return Object(i.a)(this,a),t.apply(this,arguments)}return Object(s.a)(a,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement("img",{style:{width:"50%",float:"right"},src:"/maze_solver/wall3d.png"}),r.a.createElement("p",null,'The Maze Challenge was the cultimation of the "Robotics: Science and Systems" class. The challenge is to program Wall3d (the robot in the image) to get out of an unexplored maze as fast as possible while minimizing collisions.'),r.a.createElement("p",null,"To accomplish this task, Wall3D uses SLAM, path planning, trajectory following, safety controllers, and frontier exploration."),r.a.createElement("p",null,"Our robot got the best score in the Maze Challenge. Most other approaches relied on some variation of wall following."),r.a.createElement("p",null,"Here is a video that goes through the high level explanation of how our robot works:"),r.a.createElement("div",{className:"video-wrapper"},r.a.createElement("iframe",{className:"video-frame",src:"https://www.youtube.com/embed/PrP86YrPoR0",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})),r.a.createElement("p",null,"The sildes for more details on how we use Google Cartografer for SLAM and how we process the map in order to be able to perform A*, and subsequently trajectory following, efficiently:"),r.a.createElement("div",{className:"video-wrapper"},r.a.createElement("iframe",{className:"video-frame",src:"https://docs.google.com/presentation/d/e/2PACX-1vTqXaYhTXgwJ_DPO3bpJjTPzB6wHcrB4mNkEAurd-2MHXkMApfmxKwZkfwkg2wChygbciwCbMuz_3Cd/embed?start=false&loop=false&delayms=3000",frameborder:"0",width:"960",height:"569",allowfullscreen:"true",mozallowfullscreen:"true",webkitallowfullscreen:"true"})),r.a.createElement("p",null,"One very important thing we learned in this class is that a robot is a complex system, and it can fail in many unexpected ways, as seen in this video:"),r.a.createElement("div",{className:"video-wrapper"},r.a.createElement("iframe",{className:"video-frame",src:"https://www.youtube.com/embed/bDDuAJvdg-M",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})),r.a.createElement("p",null,"Nevertheless, after dozens of hours of relentless tweaking, we got pretty good results. This was our final run:"),r.a.createElement("div",{style:{width:"100%",position:"relative"}},r.a.createElement("div",null,r.a.createElement("div",{style:{width:"50%",display:"inline-block"}},"Rviz visualization:"),r.a.createElement("div",{style:{width:"50%",display:"inline-block"}},"Reality:")),r.a.createElement("div",null,r.a.createElement("div",{style:{float:"left",width:"50%"}},r.a.createElement("iframe",{width:"100%",src:"https://www.youtube.com/embed/Otesxus6TXY",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})),r.a.createElement("div",{style:{float:"right",width:"50%"}},r.a.createElement("iframe",{width:"100%",src:"https://www.youtube.com/embed/alsAfsBNwQI",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})))),r.a.createElement("h4",null,"Conclusion"),r.a.createElement("p",null,"RSS was one of the best classes I took at MIT. It was very demanding (aprox. 20 hours/week on average) but the amount of knowledge per hour learned in this class was unparalleled. Most of the time was spent together with the team working on lab assignments. I was personally responsible for slam (using cartographer) and path planning (A*). Other members of the team were responsible for safety controllers, path following (pure pursuit) and a plan B - a simpler implementation based on wall-following."),r.a.createElement("img",{style:{width:"100%"},src:"/maze_solver/team.jpg"}))}}]),a}(n.Component),E=(a(32),function(e){Object(c.a)(a,e);var t=Object(m.a)(a);function a(){return Object(i.a)(this,a),t.apply(this,arguments)}return Object(s.a)(a,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement("h5",null,"Table of Contents:"),r.a.createElement("ol",null,r.a.createElement("li",null,r.a.createElement("a",{href:"#1"},"Overview and Motivations")),r.a.createElement("li",null,r.a.createElement("a",{href:"#2"},"Proposed Approach"),r.a.createElement("ol",{type:"a"},r.a.createElement("li",null,r.a.createElement("a",{href:"#2a"},"Frontier exploration")),r.a.createElement("li",null,r.a.createElement("a",{href:"#2b"},"Path planning")),r.a.createElement("li",null,r.a.createElement("a",{href:"#2c"},"Trajectory tracking")))),r.a.createElement("li",null,r.a.createElement("a",{href:"#3"},"Experimental Evaluation")),r.a.createElement("li",null,r.a.createElement("a",{href:"#4"},"Lessons Learned")),r.a.createElement("li",null,r.a.createElement("a",{href:"#5"},"Potential Improvements"))),r.a.createElement("div",null,r.a.createElement("h4",{id:"1"}," 1. OVERVIEW AND MOTIVATIONS "),r.a.createElement("div",null,r.a.createElement("img",{className:"halfscreen",src:"/maze_solver/maze_example.png"}),r.a.createElement("p",null,"The labyrinth final challenge involves the car being placed in an unknown maze of a given radius and having to exit the maze in a time constraint. Figure 1 illustrates an example maze that could be used. This challenge uses simultaneous localization and mapping from the localization lab so the car can generate a map of the maze as it drives and keep track of where it is in the map. This challenge also utilizes a search-based path planning algorithm from the path planning lab to create a path that represents a solution to the maze and uses the pure pursuit algorithm from the same path planning lab to follow the solution path to the exit. It is given that the maze is multicursal and not simply connected, so the car is not guaranteed to exit the maze if it uses the basic maze solving method of following one wall. The main difficulties our team is anticipating when approaching this challenge includes how to efficiently explore the map and how to ensure the car can maneuver in tight spaces (i.e. 3-point turns when leaving dead ends).")),r.a.createElement("h4",{id:"2"},"2. PROPOSED APPROACH "),r.a.createElement("p",null,"To solve the maze, we use frontier exploration to generate a map of the maze and once the car detects an area outside the radius of the maze, a path is generated for the car to follow to complete the maze. To search frontiers, our priority queue is based on proximity to the car\u2019s current location because search algorithms such as breadth-first search and depth-first search require the car to make giant leaps from one frontier to another which is not instantaneous in real life. To follow the paths generated via Dijkstra\u2019s algorithm from the car\u2019s location to the nearest frontier, the car uses pure pursuit both forwards and backwards, depending on which direction is more optimal, considering the maze has fairly tight hallways."),r.a.createElement("h5",{id:"2a"},"2.a FRONTIER EXPLORATION"),r.a.createElement("b",null,"Processing the map"),r.a.createElement("div",null,r.a.createElement("div",null,r.a.createElement("div",{className:"halfscreen"},r.a.createElement("img",{style:{width:"100%"},src:"/maze_solver/thin_walls.png"}),r.a.createElement("img",{style:{width:"100%"},src:"/maze_solver/thick_walls.png"}))),r.a.createElement("p",null,"Our team uses Google Cartographer for simultaneous localization and mapping. Cartographer outputs a grid of 20 cells/meter, each cell being assigned a value of -1 if it is \u201cunexplored\u201d or a value from 0 to 100 representing the probability of that cell being occupied. To make this map more useful and easy to work with, we downsampled it to about 10 cm/cell. We then converted it to a true occupancy grid that only contains three values: -1, 0, and 100 for \u201cunexplored\u201d, free space, and occupied, respectively. Additionally, we \u201cthickened\u201d the walls and assigned a cost to each cell based on its distance from a wall in order to avoid wall collisions.")),r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement("b",null,"Downsampling and converting the map into a true occupancy grid."),r.a.createElement("p",null,"First, we define a downsampling factor. Let\u2019s call it d. Each cell in the downsampled map is d x d cells in the original map. We consider a cell in the original map to represent a wall if its value is greater than 50. If at least 10% of the \u201coriginal\u201d cells in the downsampled cell are occupied (value > 50), then we mark the downsampled cell as occupied as well.")),r.a.createElement("li",null,r.a.createElement("b",null,"Thickening the walls"),r.a.createElement("p",null,"In order to \u201cthicken\u201d the walls on the map, we defined a procedure that creates a copy of the map, iterates through every cell, and if the cell has at least two occupied neighboring cells on the original map, the cell is marked as occupied as well. At the end, the copy is saved and the old map is removed. We repeat this process three times in order to ensure our map is sufficiently dilated.")),r.a.createElement("li",null,r.a.createElement("b",null,"Assigning costs to the cells on the map "),r.a.createElement("p",null,"If one just runs BFS on an occupancy grid, the shortest path will have sections that are very close to walls. In order to avoid this, we assign a cost to each cell based on its distance to the closest wall. The closer to a wall a cell is, the higher the associated cost. The cost of a cell we use is 2^20/2^(# cells from wall). Any cell that is more than 20 cells away from the nearest wall is assigned a cost of 0."))),r.a.createElement("h5",{id:"2b"},"2.b PATH PLANNING"),r.a.createElement("div",null,r.a.createElement("div",null,r.a.createElement("div",{className:"halfscreen"},r.a.createElement("img",{style:{width:"100%"},src:"/maze_solver/djikstra.gif"}))),r.a.createElement("p",null,"For path planning, we use Dijkstra\u2019s algorithm. The algorithm returns the path of minimal cost to the closest \u201cunexplored\u201d cell (with value -1) from the current position of the car. The cost of a path is the sum of the costs of the cells along it."),r.a.createElement("p",null,"Dijkstra\u2019s algorithm performs frontier exploration until it finds a destination. It always expands the frontier to the point of minimal distance, or cost, from the starting point."),r.a.createElement("p",null,"Due to our lidar not being able to see backwards, it is highly preferable that the paths generated be directed forward. Therefore, we draw an imaginary wall behind the car on the map and then run our path finding algorithm. If the algorithm can\u2019t find any path, we remove the wall and try generating a path again.")),r.a.createElement("h5",{id:"2c"},"2.c TRAJECTORY TRACKING"),r.a.createElement("p",null,"For trajectory tracking, we use the pure pursuit algorithm from the path planning lab. To reiterate from last lab, the pure pursuit algorithm begins by finding the segment in the trajectory that is closest to the car. Then starting from the closest segment, the algorithm iterates through the rest of the segments in the trajectory until a segment that contains a point exactly one \u201clookahead distance\u201d away from the car is found. The steering angle commanded to the car to follow the trajectory then becomes a function of the lookahead distance, the angle from the line segment made from the goal point and the car position to the car, and the car\u2019s length. The geometry and equations used for the pure pursuit algorithm are illustrated in the image below."),r.a.createElement("img",{style:{width:"100%"},src:"/maze_solver/pure_pursuit.png"}),r.a.createElement("p",null,"Since the maze has tight hallways, the car cannot always make a full turn to start following a trajectory forwards without hitting a wall. This is especially the case when the trajectory and the car are facing in opposite directions as shown on the right of Figure ___. One possible solution to this issue is to implement a three-point turn every time the car needs to turn around. However, our car uses a Velodyne lidar to collect its scan data, and this lidar cannot detect objects within 0.5 meters. This means that if the car were to begin a three-point turn, it would not be able to detect how close it is to a wall in order to change the direction of driving."),r.a.createElement("div",null,r.a.createElement("div",null,r.a.createElement("div",{className:"halfscreen"},r.a.createElement("img",{style:{width:"100%"},src:"/maze_solver/forwards_backwards.png"}))),r.a.createElement("p",null,"Therefore, we decided to incorporate pure pursuit in reverse whenever the trajectory was behind the car. All of the calculations for pure pursuit in reverse are the same as before, except the sign of the final steering angle and speed the car is commanded to drive is reversed. The metric we use in order to determine if the trajectory is in front or behind the car was the difference in angle between the first segment of the trajectory and the car\u2019s pose, both in the world frame. As shown in figure __, if the difference in angle is more than \u03c0/2, then that means the car is facing in the opposite direction of the trajectory, and pure pursuit in reverse should be used over the regular pure pursuit algorithm.")),r.a.createElement("h4",{id:"3"},"3. EXPERIMENTAL EVALUATION"),r.a.createElement("p",null,"We chose to focus our testing of the Maze Solver on real life scenarios. Due to the increased accuracy of Google Cartographer in simulation and the near-sightedness of the 3D Lidar, we decided that testing on the car would give us a better understanding of its performance for tuning and debugging purposes. We chose to evaluate our car in one maze. The maze included islands, dead ends, and tight passageways so as to mimic all possible maze scenarios. In order to collect as much data as possible, we varied the starting position of the car in the maze and measured its performance in all cases."),r.a.createElement("p",null,"We placed our car in 3 positions in the maze. For each position, we measured the distance of the shortest path from the starting position to the goal. We used this distance as a baseline measure for our car. For each of the 3 positions, we ran the maze solver 3 times. We timed the maze solver and we measured (approximately) the total distance traveled by the car. We compared these distances to the baseline of that position."),r.a.createElement("p",null,"Figure 7 indicates the approximate trajectories of the robot compared to the what the ideal trajectory would be given knowledge of the maze in advance. The trajectory of Path 1 is almost identical to that of the ideal trajectory because the robot heads towards open space and never arrives at a junction where it must decide where to go. The trajectory of Path 2 requires some extra distance covered due to the orientation of the robot. The robot is compelled to move forward until occupied space encourages the robot to turn around and head towards the ideal trajectory. Lastly, in Path 3, the robot is faced with a junction and choses to head towards a dead end before heading in the right direction. The robot also takes a longer route to get to the goal point after heading in the right direction. This explains why the standardized distance traveled is significantly greater for Path 3. Overall, standard deviation (as indicated by the error bars) for time traveled (Fig [where the time graph is]) and for distance traveled (Fig [where distance graph is]) is relatively low. This is because the frontier exploration algorithm is deterministic. Each time the robot begins in the same location and orientation, it will explore the same frontiers in the same order."),r.a.createElement("div",{style:{width:"100%",marginBottom:"30px"}},r.a.createElement("img",{src:"/maze_solver/experiments.jpg",style:{width:"100%"}})),r.a.createElement("h4",{id:"4"},"4. LESSONS LEARNED "),r.a.createElement("p",null,"Over the course of this challenge, we learned the importance of prioritizing tasks and having a back-up algorithm."),r.a.createElement("p",null,"At times in the lab, we focused on making the path finding and pure pursuit algorithms more robust while the basic movements of the maze solver did not work as anticipated. For example, we tried to implement dubens curves prior to having a working maze solver. This attempt to improve an already broken algorithm delayed our finding of a minimum viable product, costing the team invaluable time."),r.a.createElement("p",null,"At the same time, we learned that having a simple backup algorithm is essential should the more robust algorithm not be completed. For this task, we realized that a stochastic wall follower algorithm could replace our pure pursuit controller to guide the car through the maze. While a wall follower would most likely take more time to solve a maze, it would at least be able to explore the maze."),r.a.createElement("h4",{id:"5"},"5. POTENTIAL IMPROVEMENTS"),r.a.createElement("p",null,"Our current implementation of a maze solver works well, but it has some issues and there are a lot of improvements we could implement in order to make it more robust."),r.a.createElement("p",null,"The dynamics of the car itself are really important for path planning, but our current implementation does not take these into account. Our current path-planning algorithm for the maze works by using nodes and making paths between these nodes using Dijkstra's algorithm. The nodes are just cells from our down-sampled map, and the cost associated with them is determined by how close the cell is to a wall. By finding the least-cost path through this maze, we try to avoid walls. The issue with this implementation is that it is purely based upon cell cost. The turning radius of the car is never taken into account. As a result, we sometimes publish paths that the car cannot physically follow. We currently rely on our safety controller to get us out of these situations where the car could collide with an object. Using another representation of trajectories such as *dubin* curves would enable us to create smoother paths that would help both avoiding collisions as well as driving with pure pursuit. Having these smoother paths that take into account car dynamics would also allow us to increase the speed at which the car travels. Currently the car explores the car explores the maze slowly because of these uneven paths and to allow the safety controller to kick in soon enough to avoid obstacles."),r.a.createElement("p",null,"Another issue we ran into with our current implementation is that because our current generated paths are only dependent upon low-cost and nearest frontier, we run into the issue where we cannot find a goal point for pure pursuit because our lookahead distance is static. Sometimes the start point of the trajectory is slightly too far from the car and sometimes the end of the trajectory is too close (because the maze environment is concave, the absolute distance between the start and end of a path can be less than one lookahead distance). Our current solution for this problem is generating a new path when we cannot find a goal point for the current one. This is not the most efficient solution, as this means we are no longer exploring the closest frontier and it is computationally expensive to generate new paths, which takes time (as can be seen when the car pauses in the maze to generate new paths). A better solution would be to make a dynamic look-ahead distance and change it accordingly based upon what path is generated and the position of the car with respect to that path."),r.a.createElement("p",null,"Our current lidar is only capable of seeing objects with a minimum distance of 0.5 meters. If an object is closer than 0.5 meters, then the lidar views this as an object that is an infinite distance away. We currently run into issues where our car will re-map a previously discovered wall as not existing because it gets within 0.5 meters of it and thinks that nothing is there. As a result, sometimes paths are generated that go through walls. This happens very rarely, but when it does we rely on wall dilation as well as our safety controller. One proposed solution to this problem is that when we receive a scan of distance infinity from our lidar, we change it to a random number between 0.0 and 0.5 using a uniform distribution. This would solve the issue of deleting/re-mapping pre-existing walls as well as help us avoid generating paths too close to walls. The problem with this is that if a path in the maze is 1 meter or less wide, our car would never be able to traverse it, and would always map that something exists there. Another solution is to find these specific laser scans in the data, and remove them before we send the lidar data to Google Cartographer. This means that no scans that are of a value of infinity would be used, avoiding the remapping of walls. We will test both solutions in future to determine which one is more optimal, but it may vary based upon environment."),r.a.createElement("p",null,"As previously discussed, we want our car to avoid bumping into walls/obstacles at all costs. Currently we dilate our walls using a nearest-neighbors method. This does not always work, as sometimes there are paths being generated that go too close to walls. In the future, we want to dilate our map more to avoid paths that are too close to walls, but we also have to figure out a way to not dilate so much that narrow passages are blocked off. Dilating the map works well for mazes that are more open, but for mazes that are more narrow, it could block off some of the maze."),r.a.createElement("p",null,"Lastly, we want to implement a \u201cdrive to the end\u201d functionality for the car. Our current path planning only looks for the nearest frontier, and creates a path there. However, if we are trying to escape a maze of a given radius, if we discover a point that is outside this given radius, we want to drive there immediately. We did not implement this because it was too computationally expensive to check if a point was discovered outside the radius every time the car wanted to plan a new path."),r.a.createElement("ul",null,r.a.createElement("li",null,"Creating paths that are more geared towards car maneuverability x"),r.a.createElement("li",null,"Dynamic lookahead distance for pure pursuit"),r.a.createElement("li",null,"Not using a velodyne for this maze - Improving upon velodyne remapping because a space is within 0.5m"),r.a.createElement("li",null,"If it discovers an open space far enough away, drive there immediately"),r.a.createElement("li",null,"Computationally expensive"),r.a.createElement("li",null,"Dilating walls more to avoid wall collisions, improving safety controller"),r.a.createElement("li",null,"Faster maze movement (but cartographer wacks out)"))))}}]),a}(n.Component)),v=function(e){Object(c.a)(a,e);var t=Object(m.a)(a);function a(){return Object(i.a)(this,a),t.apply(this,arguments)}return Object(s.a)(a,[{key:"render",value:function(){return r.a.createElement("div",{style:{textAlign:"justify"}},r.a.createElement("h2",null," Wall3D: Maze Solving Challenge "),r.a.createElement("p",{align:"middle"},r.a.createElement("i",null,"Team 9: Talia Pelts, Kevin Carlson, Jonathan Samayoa, Susan Ni, Vlad Seremet")),r.a.createElement(w.a,{defaultActiveKey:"overview",style:{fontWeight:"bold"},id:"uncontrolled-tab-example"},r.a.createElement(h.a,{eventKey:"overview",title:"General Overview"},r.a.createElement(b,null)),r.a.createElement(h.a,{eventKey:"report",title:"Technical Report"},r.a.createElement(E,null))))}}]),a}(n.Component),y=function(e){Object(c.a)(a,e);var t=Object(m.a)(a);function a(){return Object(i.a)(this,a),t.apply(this,arguments)}return Object(s.a)(a,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement("h2",null,"HarvesR: using reinforcement learning for fruit picking"))}}]),a}(n.Component),k=function(e){Object(c.a)(a,e);var t=Object(m.a)(a);function a(){return Object(i.a)(this,a),t.apply(this,arguments)}return Object(s.a)(a,[{key:"render",value:function(){return r.a.createElement("div",null,r.a.createElement("h2",null,"Platformer: a fun 2D game"))}}]),a}(n.Component),x=function(e){Object(c.a)(a,e);var t=Object(m.a)(a);function a(){return Object(i.a)(this,a),t.apply(this,arguments)}return Object(s.a)(a,[{key:"render",value:function(){return r.a.createElement(h.a.Container,{id:"left-tabs-example",defaultActiveKey:"first"},r.a.createElement(u.a,null,r.a.createElement(d.a,{lg:3},r.a.createElement(p.a,{variant:"tabs",className:"flex-column"},r.a.createElement(p.a.Item,null,r.a.createElement(g.b,{to:"/projects/maze_solver",className:"navlink navlink-left",activeStyle:{border:"1px solid black",borderRadius:"10px"},exact:!0},"Maze Solver")),r.a.createElement(p.a.Item,null,r.a.createElement(g.b,{to:"/projects/harvestr",className:"navlink navlink-left",activeStyle:{border:"1px solid black",borderRadius:"10px"},exact:!0},"HarvestR")),r.a.createElement(p.a.Item,null,r.a.createElement(g.b,{to:"/projects/platformer",className:"navlink navlink-left",activeStyle:{border:"1px solid black",borderRadius:"10px"},exact:!0},"Platformer")))),r.a.createElement(d.a,{lg:9},r.a.createElement(h.a.Content,null,r.a.createElement(f.a,{path:"/projects/maze_solver",component:v,exact:!0}),r.a.createElement(f.a,{path:"/projects/harvestr",component:y,exact:!0}),r.a.createElement(f.a,{path:"/projects/platformer",component:k,exact:!0})))))}}]),a}(n.Component),j=function(e){Object(c.a)(a,e);var t=Object(m.a)(a);function a(){return Object(i.a)(this,a),t.apply(this,arguments)}return Object(s.a)(a,[{key:"render",value:function(){return r.a.createElement("div",{style:{verticalAlign:"center"}},r.a.createElement("table",{id:"t",width:"100%",style:{textAlign:"left",verticalAlign:"center",margin:"20px"}},r.a.createElement("tbody",null,r.a.createElement("tr",null,r.a.createElement("td",null,r.a.createElement("h4",null,"Education"))),r.a.createElement("tr",null,r.a.createElement("td",{width:"80%"},r.a.createElement("b",null,"Massachusetts Institute of Technology "),r.a.createElement("br",null),r.a.createElement("div",{className:"subtitle"},"Relevant Coursework: \xa0",r.a.createElement("a",{href:"https://mc.ai/6-141-robotics-science-systems-a-review/",target:"_blank"},"Robotics: Science and Systems,"),"\xa0",r.a.createElement("a",{href:"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-172-performance-engineering-of-software-systems-fall-2018/",target:"_blank"},"Performance Engineering of Software Systems*,"),"\xa0",r.a.createElement("a",{href:"http://web.mit.edu/6.033/www/general.shtml",target:"_blank"},"Computer Systems Engineering*,"),"\xa0",r.a.createElement("a",{href:"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/",target:"_blank"},"Elements of Software Construction*,"),"\xa0",r.a.createElement("a",{href:"http://courses.csail.mit.edu/6.036/",target:"_blank"},"Machine Learning,"),"\xa0",r.a.createElement("a",{href:"https://py.mit.edu/fall20",target:"_blank"},"Fundamentals of Programming,"),"\xa0",r.a.createElement("a",{href:"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/",target:"_blank"},"Introduction to Algorithms,"),"\xa0",r.a.createElement("a",{href:"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/",target:"_blank"},"Introduction to Data Science,"),"\xa0",r.a.createElement("a",{href:"https://courses.csail.mit.edu/6.042/spring18/classinfo.shtml",target:"_blank"},"Mathematics for Computer Science,"),"\xa0",r.a.createElement("a",{href:"https://www.eecs.mit.edu/academics-admissions/academic-information/subject-updates-spring-2020/6884",target:"_blank"},"Computational Sensorimotor Learning*"),"\xa0",r.a.createElement("a",{href:"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-004-computation-structures-spring-2017/",target:"_blank"},"Computation Structures*,"),r.a.createElement("br",null),"* - project based class")),r.a.createElement("td",{width:"20%",style:{textAlign:"center"}},"Cambridge, MA ",r.a.createElement("br",null),"2015-2020")),r.a.createElement("tr",null,r.a.createElement("td",{style:{paddingTop:"20px"}},r.a.createElement("h4",null,"Experience"))),r.a.createElement("tr",null,r.a.createElement("td",{width:"80%"},r.a.createElement("b",null,r.a.createElement("a",{href:"http://darbelofflab.mit.edu/",target:"_blank"},"MIT D\u2019Arbeloff Laboratory")),r.a.createElement("div",{className:"subtitle"},"Undergraduate Research Assistant \u2013 UROP in robotics")),r.a.createElement("td",{width:"20%",style:{textAlign:"center"}},"Cambridge, MA ",r.a.createElement("br",null),"Feb.\u201819 \u2013 May \u201819")),r.a.createElement("tr",null,r.a.createElement("ul",null,r.a.createElement("li",null," Programmed a UR robotic arm as part of \xa0",r.a.createElement("a",{href:"http://www.mit.edu/~nselby/teachbot.html",target:"_blank"},"TeachBot - an interactive apprenticeship program.")),r.a.createElement("li",null," Worked with ROS, MoveIt, ReactJs, ExpressJs."))),r.a.createElement("tr",null,r.a.createElement("td",{width:"80%"},r.a.createElement("b",null,"Amazon Web Services"),r.a.createElement("div",{className:"subtitle"},"Software Engineering Intern")),r.a.createElement("td",{width:"20%",style:{textAlign:"center"}},"Berlin, Germany",r.a.createElement("br",null),"Jun.-Aug. 2017")),r.a.createElement("tr",null,r.a.createElement("ul",null,r.a.createElement("li",null," Improved the refund approval workflow by building a microservice that helps tech assistants review purchase history."),r.a.createElement("li",null," Technologies used: AngularJS, ExpressJS, Java, Other internal AWS tools"))),r.a.createElement("tr",null,r.a.createElement("td",{width:"80%"},r.a.createElement("b",null,r.a.createElement("a",{href:"http://acl.mit.edu/",target:"_blank"},"MIT Aerospace Controls Lab")),r.a.createElement("div",{className:"subtitle"},"Undergraduate Research Assistant - UROP in Machine Learning/Robotics")),r.a.createElement("td",{width:"20%",style:{textAlign:"center"}},"Cambridge, MA",r.a.createElement("br",null),"Feb. \u2013 May. \u201817")),r.a.createElement("tr",null,r.a.createElement("ul",null,r.a.createElement("li",null," Created a pipeline for automated acquisition, and processing of image datasets."),r.a.createElement("li",null," Designed and tested algorithms for \xa0",r.a.createElement("a",{href:"http://acl.mit.edu/projects/socially-acceptable-navigation",target:"_blank"},"navigating through crowds while avoiding collisions.")))),r.a.createElement("tr",null,r.a.createElement("td",{width:"80%"},r.a.createElement("b",null,"MIT"),r.a.createElement("div",{className:"subtitle"},"Teacher Assistant for  \xa0",r.a.createElement("a",{href:"https://py.mit.edu/fall20",target:"_blank"},"6.009 (fundamentals of programming using Python)"))),r.a.createElement("td",{width:"20%",style:{textAlign:"center"}},"Cambridge, MA",r.a.createElement("br",null),"Sep. \u201817 \u2013 May \u201818")),r.a.createElement("tr",null,r.a.createElement("ul",null,r.a.createElement("li",null,"Helped teachers with assignments and student assistance."),r.a.createElement("li",null,"Explained concepts such as iteration, recursion, data structures in python, debugging techniques, writing efficient code, \u201cthe pythonic way\u201d etc."))),r.a.createElement("tr",null,r.a.createElement("td",{width:"80%"},r.a.createElement("b",null,r.a.createElement("a",{href:"https://oneshore.com/",target:"_blank"},"OneShore Energy GmbH")),r.a.createElement("div",{className:"subtitle"},"Software Engineering Intern")),r.a.createElement("td",{width:"20%",style:{textAlign:"center"}},"Berlin, Germany",r.a.createElement("br",null),"Summer 2016")),r.a.createElement("tr",null,r.a.createElement("ul",null,r.a.createElement("li",null,"Improved the data visualization process by developing a dashboard using Django on the backend and HTML/CSS/JS (jQuery, highcharts) on the frontend."),r.a.createElement("li",null,"Debugged and improved the efficiency of a simulation tool that predicts the performance of the electrical system (replaced and improved some algorithms and data structures used in the simulation and replaced some Python code with C++)."))),r.a.createElement("tr",null,r.a.createElement("td",null,r.a.createElement("h4",null,"Leadership"))),r.a.createElement("tr",null,r.a.createElement("td",{width:"80%"},r.a.createElement("b",null,r.a.createElement("a",{href:"https://gelp.mit.edu/",target:"_blank"},"Gordon Engineering Leadership Program")),r.a.createElement("div",{className:"subtitle"},"Trainee")),r.a.createElement("td",{width:"20%",style:{textAlign:"center"}},"Cambridge, MA ",r.a.createElement("br",null),"2017")),r.a.createElement("tr",null,r.a.createElement("td",{width:"80%"},r.a.createElement("b",null,r.a.createElement("a",{href:"https://waveweekmoldova.wordpress.com/",target:"_blank"},"Wave Week Moldova \u2013 a leadership program for students")),r.a.createElement("div",{className:"subtitle"},"Staff member and coach")),r.a.createElement("td",{width:"20%",style:{textAlign:"center"}},"Chisinau, Moldova",r.a.createElement("br",null),"2012-2015")),r.a.createElement("tr",null,r.a.createElement("td",{width:"80%"},r.a.createElement("b",null,"English Debate Club at the \xa0",r.a.createElement("a",{href:"https://americahouse.md/",target:"_blank"},"American Resource Center")),r.a.createElement("div",{className:"subtitle"},"Moderator and Coach")),r.a.createElement("td",{width:"20%",style:{textAlign:"center"}},"Chisinau, Moldova",r.a.createElement("br",null),"2014-2015")))),r.a.createElement("table",{id:"t",width:"100%",style:{textAlign:"left",verticalAlign:"center",margin:"20px"}},r.a.createElement("tr",null,r.a.createElement("td",null,r.a.createElement("h4",null,"Skills"))),r.a.createElement("tr",null,r.a.createElement("td",{width:"20%"}," ",r.a.createElement("b",null," Robotics: ")," "),r.a.createElement("td",{width:"80%"},"ROS, Gazebo, Unity ML-Agents, MuJoCo, Pybullet, Fusion 360, Solidworks, Blender")),r.a.createElement("tr",null,r.a.createElement("td",{width:"20%"}," ",r.a.createElement("b",null," AI/ML: ")," "),r.a.createElement("td",{width:"80%"},"Pytorch, reverb, CNNs, Autoencoders, Object Instance/Semantic segmentation")),r.a.createElement("tr",null,r.a.createElement("td",{width:"20%"}," ",r.a.createElement("b",null," WebDev: ")," "),r.a.createElement("td",{width:"80%"},"Django, JQuery, ReactJS, ExpressJS, HTML/CSS/JS")),r.a.createElement("tr",null,r.a.createElement("td",{width:"20%"}," ",r.a.createElement("b",null," Other: ")," "),r.a.createElement("td",{width:"80%"},"Linux, Docker, Arduino, Adobe Photoshop, git, vim, web scraping, violin, piano, drums")),r.a.createElement("tr",null,r.a.createElement("td",{width:"20%"}," ",r.a.createElement("b",null," Languages: ")," "),r.a.createElement("td",{width:"80%"},"Romanian (native), Russian (fluent), English (fluent), German (beginner)"))))}}]),a}(n.Component),z=function(e){Object(c.a)(a,e);var t=Object(m.a)(a);function a(){return Object(i.a)(this,a),t.apply(this,arguments)}return Object(s.a)(a,[{key:"render",value:function(){return r.a.createElement("div",{style:{background:"url('/bg.JPG')",backgroundSize:"contain",backgroundRepeat:"no-repeat",width:"100%",height:"1000px",color:"white"}},r.a.createElement("div",{style:{padding:"10px 0px 0px 10px",textAlign:"left",display:"inline-block",float:"left",width:"65%",fontSize:"3vw"}},r.a.createElement("b",null,"Main interests:"),r.a.createElement("ul",null,r.a.createElement("li",null,"Robotics"),r.a.createElement("li",null,"Reinforcement Learning"),r.a.createElement("li",null,"Computer Vision"))))}}]),a}(n.Component);a(59);var T=function(){return r.a.createElement(g.a,{basename:""},r.a.createElement("div",{className:"App main-container"},r.a.createElement("div",{className:"navbar"},r.a.createElement("div",{className:"left"},r.a.createElement(g.b,{to:"/",exact:!0,style:{color:"black",textDecoration:"none"}},r.a.createElement("h2",null,"Vlad Seremet"))),r.a.createElement("div",{className:"right",style:{fontSize:"20"}},r.a.createElement(g.b,{to:"/resume",className:"navlink",activeStyle:{borderBottom:"1px solid black"},exact:!0},"Resume"),r.a.createElement(g.b,{to:"/projects/maze_solver",className:"navlink",activeStyle:{borderBottom:"solid 1px black"},exact:!0},"Projects"),r.a.createElement(g.b,{to:"/blog",className:"navlink",activeStyle:{borderBottom:"solid 1px black"}},"Blog"))),r.a.createElement(f.a,{path:"/",component:z,exact:!0}),r.a.createElement(f.a,{path:"/resume",component:j,exact:!0}),r.a.createElement(f.a,{path:"/projects",component:x})))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));o.a.render(r.a.createElement(r.a.StrictMode,null,r.a.createElement(T,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()})).catch((function(e){console.error(e.message)}))}},[[43,1,2]]]);
//# sourceMappingURL=main.c7ec906f.chunk.js.map